export namespace interaction {
    /**
     * Interact with an element by clicking it.
     *
     * The element is scrolled into view before visibility- or interactability
     * checks are performed.
     *
     * Selenium-style visibility checks will be performed
     * if <var>specCompat</var> is false (default).  Otherwise
     * pointer-interactability checks will be performed.  If either of these
     * fail an {@link ElementNotInteractableError} is thrown.
     *
     * If <var>strict</var> is enabled (defaults to disabled), further
     * accessibility checks will be performed, and these may result in an
     * {@link ElementNotAccessibleError} being returned.
     *
     * When <var>el</var> is not enabled, an {@link InvalidElementStateError}
     * is returned.
     *
     * @param {(DOMElement|XULElement)} el
     *     Element to click.
     * @param {boolean=} [strict=false] strict
     *     Enforce strict accessibility tests.
     * @param {boolean=} [specCompat=false] specCompat
     *     Use WebDriver specification compatible interactability definition.
     *
     * @throws {ElementNotInteractableError}
     *     If either Selenium-style visibility check or
     *     pointer-interactability check fails.
     * @throws {ElementClickInterceptedError}
     *     If <var>el</var> is obscured by another element and a click would
     *     not hit, in <var>specCompat</var> mode.
     * @throws {ElementNotAccessibleError}
     *     If <var>strict</var> is true and element is not accessible.
     * @throws {InvalidElementStateError}
     *     If <var>el</var> is not enabled.
     */
    function clickElement(el: any, strict?: boolean, specCompat?: boolean): Promise<void>;
    /**
     * Select <tt>&lt;option&gt;</tt> element in a <tt>&lt;select&gt;</tt>
     * list.
     *
     * Because the dropdown list of select elements are implemented using
     * native widget technology, our trusted synthesised events are not able
     * to reach them.  Dropdowns are instead handled mimicking DOM events,
     * which for obvious reasons is not ideal, but at the current point in
     * time considered to be good enough.
     *
     * @param {HTMLOptionElement} el
     *     Option element to select.
     *
     * @throws {TypeError}
     *     If <var>el</var> is a XUL element or not an <tt>&lt;option&gt;</tt>
     *     element.
     * @throws {Error}
     *     If unable to find <var>el</var>'s parent <tt>&lt;select&gt;</tt>
     *     element.
     */
    function selectOption(el: HTMLOptionElement): void;
    /**
     * Clears the form control or the editable element, if required.
     *
     * Before clearing the element, it will attempt to scroll it into
     * view if it is not already in the viewport.  An error is raised
     * if the element cannot be brought into view.
     *
     * If the element is a submittable form control and it is empty
     * (it has no value or it has no files associated with it, in the
     * case it is a <code>&lt;input type=file&gt;</code> element) or
     * it is an editing host and its <code>innerHTML</code> content IDL
     * attribute is empty, this function acts as a no-op.
     *
     * @param {Element} el
     *     Element to clear.
     *
     * @throws {InvalidElementStateError}
     *     If element is disabled, read-only, non-editable, not a submittable
     *     element or not an editing host, or cannot be scrolled into view.
     */
    function clearElement(el: Element): void;
    /**
     * Waits until the event loop has spun enough times to process the
     * DOM events generated by clicking an element, or until the document
     * is unloaded.
     *
     * @param {Element} el
     *     Element that is expected to receive the click.
     *
     * @returns {Promise}
     *     Promise is resolved once <var>el</var> has been clicked
     *     (its <code>click</code> event fires), the document is unloaded,
     *     or a 500 ms timeout is reached.
     */
    function flushEventLoop(el: Element): Promise<any>;
    /**
     * If <var>el<var> is a textual form control, or is contenteditable,
     * and no previous selection state exists, move the caret to the end
     * of the form control.
     *
     * The element has to be a <code>&lt;input type=text&gt;</code> or
     * <code>&lt;textarea&gt;</code> element, or have the contenteditable
     * attribute set, for the cursor to be moved.
     *
     * @param {Element} el
     *     Element to potential move the caret in.
     */
    function moveCaretToEnd(el: Element): void;
    /**
     * Performs checks if <var>el</var> is keyboard-interactable.
     *
     * To decide if an element is keyboard-interactable various properties,
     * and computed CSS styles have to be evaluated. Whereby it has to be taken
     * into account that the element can be part of a container (eg. option),
     * and as such the container has to be checked instead.
     *
     * @param {Element} el
     *     Element to check.
     *
     * @returns {boolean}
     *     True if element is keyboard-interactable, false otherwise.
     */
    function isKeyboardInteractable(el: Element): boolean;
    /**
     * Updates an `<input type=file>`'s file list with given `paths`.
     *
     * Hereby will the file list be appended with `paths` if the
     * element allows multiple files. Otherwise the list will be
     * replaced.
     *
     * @param {HTMLInputElement} el
     *     An `input type=file` element.
     * @param {Array.<string>} paths
     *     List of full paths to any of the files to be uploaded.
     *
     * @throws {InvalidArgumentError}
     *     If `path` doesn't exist.
     */
    function uploadFiles(el: HTMLInputElement, paths: string[]): Promise<void>;
    /**
     * Sets a form element's value.
     *
     * @param {DOMElement} el
     *     An form element, e.g. input, textarea, etc.
     * @param {string} value
     *     The value to be set.
     *
     * @throws {TypeError}
     *     If <var>el</var> is not an supported form element.
     */
    function setFormControlValue(el: DOMElement, value: string): void;
    /**
     * Send keys to element.
     *
     * @param {DOMElement|XULElement} el
     *     Element to send key events to.
     * @param {Array.<string>} value
     *     Sequence of keystrokes to send to the element.
     * @param {object=} options
     * @param {boolean=} options.strictFileInteractability
     *     Run interactability checks on `<input type=file>` elements.
     * @param {boolean=} options.accessibilityChecks
     *     Enforce strict accessibility tests.
     * @param {boolean=} options.webdriverClick
     *     Use WebDriver specification compatible interactability definition.
     */
    function sendKeysToElement(el: any, value: string[], { strictFileInteractability, accessibilityChecks, webdriverClick, }?: any): Promise<void>;
    /**
     * Determine the element displayedness of an element.
     *
     * @param {DOMElement|XULElement} el
     *     Element to determine displayedness of.
     * @param {boolean=} [strict=false] strict
     *     Enforce strict accessibility tests.
     *
     * @returns {boolean}
     *     True if element is displayed, false otherwise.
     */
    function isElementDisplayed(el: any, strict?: boolean): boolean;
    /**
     * Check if element is enabled.
     *
     * @param {DOMElement|XULElement} el
     *     Element to test if is enabled.
     *
     * @returns {boolean}
     *     True if enabled, false otherwise.
     */
    function isElementEnabled(el: any, strict?: boolean): boolean;
    /**
     * Determines if the referenced element is selected or not, with
     * an additional accessibility check if <var>strict</var> is true.
     *
     * This operation only makes sense on input elements of the checkbox-
     * and radio button states, and option elements.
     *
     * @param {(DOMElement|XULElement)} el
     *     Element to test if is selected.
     * @param {boolean=} [strict=false] strict
     *     Enforce strict accessibility tests.
     *
     * @returns {boolean}
     *     True if element is selected, false otherwise.
     *
     * @throws {ElementNotAccessibleError}
     *     If <var>el</var> is not accessible when <var>strict</var> is true.
     */
    function isElementSelected(el: any, strict?: boolean): boolean;
}
