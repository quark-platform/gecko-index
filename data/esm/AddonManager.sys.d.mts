export const AMTelemetry: any;
export const AMRemoteSettings: any;
export const AMBrowserExtensionsImport: any;
export namespace AddonManagerPrivate {
    export function startup(): void;
    export function addonIsActive(addonId: any): any;
    /**
     * Gets an array of add-ons which were side-loaded prior to the last
     * startup, and are currently disabled.
     *
     * @returns {Promise<Array<Addon>>}
     */
    export function getNewSideloads(): Promise<Addon[]>;
    export const browserUpdated: any;
    export function registerProvider(aProvider: any, aTypes: any): void;
    export function unregisterProvider(aProvider: any): void;
    /**
     * Get a list of addon types that was passed to registerProvider for the
     * provider with the given name.
     *
     * @param {string} aProviderName
     * @returns {Array<string>}
     */
    export function getAddonTypesByProvider(aProviderName: string): string[];
    export function markProviderSafe(aProvider: any): void;
    export function backgroundUpdateCheck(): Promise<void>;
    export function backgroundUpdateTimerHandler(): void;
    export function addStartupChange(aType: any, aID: any): void;
    export function removeStartupChange(aType: any, aID: any): void;
    export function notifyAddonChanged(aID: any, aType: any, aPendingRestart: any): Promise<void>;
    export function updateAddonAppDisabledStates(): void;
    export function updateAddonRepositoryData(): Promise<void>;
    export function callInstallListeners(...aArgs: any[]): any;
    export function callAddonListeners(...aArgs: any[]): void;
    export { AddonAuthor };
    export { AddonScreenshot };
    export const BOOTSTRAP_REASONS: any;
    export function setAddonStartupData(addonId: any, startupData: any): void;
    export function unregisterDictionaries(aDicts: any): void;
    export function recordTimestamp(name: any, value: any): void;
    export let _simpleMeasures: {};
    export function recordSimpleMeasure(name: any, value: any): void;
    export function recordException(aModule: any, aContext: any, aException: any): void;
    export function getSimpleMeasures(): {};
    export function getTelemetryDetails(): {};
    export function setTelemetryDetails(aProvider: any, aDetails: any): void;
    export function simpleTimer(aName: any): {
        done: () => void;
    };
    export function recordTiming(name: any, task: any): Promise<any>;
    /**
     * Helper to call update listeners when no update is available.
     *
     * This can be used as an implementation for Addon.findUpdates() when
     * no update mechanism is available.
     */
    export function callNoUpdateListeners(addon: any, listener: any, reason: any, appVersion: any, platformVersion: any): void;
    export const webExtensionsMinPlatformVersion: string;
    export function hasUpgradeListener(aId: any): boolean;
    export function getUpgradeListener(aId: any): any;
    export const externalExtensionLoaders: Map<any, any>;
    /**
     * Predicate that returns true if we think the given extension ID
     * might have been generated by XPIProvider.
     */
    export function isTemporaryInstallID(extensionId: any): any;
    export function isDBLoaded(): any;
    export const databaseReady: any;
    export const finalShutdown: any;
    export function overrideAddonRepository(mockRepo: any): void;
    export function overrideAsyncShutdown(mockAsyncShutdown: any): void;
}
export namespace AddonManager {
    export let _installHostSource: Map<string, string>;
    export let _states: Map<string, number>;
    export let _errors: Map<string, number>;
    export let ERROR_TIMEOUT: number;
    export let ERROR_DOWNLOAD_ERROR: number;
    export let ERROR_PARSE_ERROR: number;
    export let ERROR_UNKNOWN_FORMAT: number;
    export let ERROR_SECURITY_ERROR: number;
    export let ERROR_CANCELLED: number;
    export let UPDATE_STATUS_NO_ERROR: number;
    export let UPDATE_STATUS_TIMEOUT: number;
    export let UPDATE_STATUS_DOWNLOAD_ERROR: number;
    export let UPDATE_STATUS_PARSE_ERROR: number;
    export let UPDATE_STATUS_UNKNOWN_FORMAT: number;
    export let UPDATE_STATUS_SECURITY_ERROR: number;
    export let UPDATE_STATUS_CANCELLED: number;
    export let UPDATE_WHEN_USER_REQUESTED: number;
    export let UPDATE_WHEN_NEW_APP_DETECTED: number;
    export let UPDATE_WHEN_NEW_APP_INSTALLED: number;
    export let UPDATE_WHEN_PERIODIC_UPDATE: number;
    export let UPDATE_WHEN_ADDON_INSTALLED: number;
    export let PENDING_NONE: number;
    export let PENDING_ENABLE: number;
    export let PENDING_DISABLE: number;
    export let PENDING_UNINSTALL: number;
    export let PENDING_INSTALL: number;
    export let PENDING_UPGRADE: number;
    export let OP_NEEDS_RESTART_NONE: number;
    export let OP_NEEDS_RESTART_ENABLE: number;
    export let OP_NEEDS_RESTART_DISABLE: number;
    export let OP_NEEDS_RESTART_UNINSTALL: number;
    export let OP_NEEDS_RESTART_INSTALL: number;
    export let PERM_CAN_UNINSTALL: number;
    export let PERM_CAN_ENABLE: number;
    export let PERM_CAN_DISABLE: number;
    export let PERM_CAN_UPGRADE: number;
    export let PERM_CAN_CHANGE_PRIVATEBROWSING_ACCESS: number;
    export let PERM_API_CAN_UNINSTALL: number;
    export let SCOPE_PROFILE: number;
    export let SCOPE_USER: number;
    export let SCOPE_APPLICATION: number;
    export let SCOPE_SYSTEM: number;
    export let SCOPE_TEMPORARY: number;
    export let SCOPE_ALL: number;
    export let AUTOUPDATE_DISABLE: number;
    export let AUTOUPDATE_DEFAULT: number;
    export let AUTOUPDATE_ENABLE: number;
    export let OPTIONS_TYPE_TAB: number;
    export let OPTIONS_TYPE_INLINE_BROWSER: number;
    export let OPTIONS_NOTIFICATION_DISPLAYED: string;
    export let OPTIONS_NOTIFICATION_HIDDEN: string;
    export let STARTUP_CHANGE_INSTALLED: string;
    export let STARTUP_CHANGE_CHANGED: string;
    export let STARTUP_CHANGE_UNINSTALLED: string;
    export let STARTUP_CHANGE_DISABLED: string;
    export let STARTUP_CHANGE_ENABLED: string;
    export let SIGNEDSTATE_NOT_REQUIRED: any;
    export let SIGNEDSTATE_BROKEN: number;
    export let SIGNEDSTATE_UNKNOWN: number;
    export let SIGNEDSTATE_MISSING: number;
    export let SIGNEDSTATE_PRELIMINARY: number;
    export let SIGNEDSTATE_SIGNED: number;
    export let SIGNEDSTATE_SYSTEM: number;
    export let SIGNEDSTATE_PRIVILEGED: number;
    export namespace __AddonManagerInternal__ {
        export let managerListeners: Set<any>;
        export let installListeners: Set<any>;
        export let addonListeners: Set<any>;
        export let pendingProviders: Set<any>;
        export let providers: Set<any>;
        export let providerShutdowns: Map<any, any>;
        export let typesByProvider: Map<any, any>;
        export let startupChanges: {};
        export let telemetryDetails: {};
        export let upgradeListeners: Map<any, any>;
        let externalExtensionLoaders_1: Map<any, any>;
        export { externalExtensionLoaders_1 as externalExtensionLoaders };
        export function recordTimestamp(name: any, value: any): void;
        /**
         * Start up a provider, and register its shutdown hook if it has one
         *
         * @param {string} aProvider - An add-on provider.
         * @param {boolean} aAppChanged - Whether or not the app version has changed since last session.
         * @param {string} aOldAppVersion - Previous application version, if changed.
         * @param {string} aOldPlatformVersion - Previous platform version, if changed.
         *
         * @private
         */
        export function _startProvider(aProvider: string, aAppChanged: boolean, aOldAppVersion: string, aOldPlatformVersion: string): void;
        export function _getProviderByName(aName: any): any;
        /**
         * Initializes the AddonManager, loading any known providers and initializing
         * them.
         */
        export function startup(): void;
        /**
         * Registers a new AddonProvider.
         *
         * @param {string} aProvider -The provider to register
         * @param {string[]} [aTypes] - An optional array of add-on types
         */
        export function registerProvider(aProvider: string, aTypes?: string[]): void;
        /**
         * Unregisters an AddonProvider.
         *
         * @param  aProvider
         *         The provider to unregister
         * @return Whatever the provider's 'shutdown' method returns (if anything).
         *         For providers that have async shutdown methods returning Promises,
         *         the caller should wait for that Promise to resolve.
         */
        export function unregisterProvider(aProvider: any): any;
        /**
         * Mark a provider as safe to access via AddonManager APIs, before its
         * startup has completed.
         *
         * Normally a provider isn't marked as safe until after its (synchronous)
         * startup() method has returned. Until a provider has been marked safe,
         * it won't be used by any of the AddonManager APIs. markProviderSafe()
         * allows a provider to mark itself as safe during its startup; this can be
         * useful if the provider wants to perform tasks that block startup, which
         * happen after its required initialization tasks and therefore when the
         * provider is in a safe state.
         *
         * @param aProvider Provider object to mark safe
         */
        export function markProviderSafe(aProvider: any): void;
        /**
         * Calls a method on all registered providers if it exists and consumes any
         * thrown exception. Return values are ignored. Any parameters after the
         * method parameter are passed to the provider's method.
         * WARNING: Do not use for asynchronous calls; callProviders() does not
         * invoke callbacks if provider methods throw synchronous exceptions.
         *
         * @param  aMethod
         *         The method name to call
         */
        export function callProviders(aMethod: any, ...aArgs: any[]): void;
        /**
         * Report the current state of asynchronous shutdown
         */
        export function shutdownState(): {
            name: any;
            state: any;
        }[];
        /**
         * Shuts down the addon manager and all registered providers, this must clean
         * up everything in order for automated tests to fake restarts.
         * @return Promise{null} that resolves when all providers and dependent modules
         *                       have finished shutting down
         */
        export function shutdownManager(): Promise<void>;
        /**
         * Notified when a preference we're interested in has changed.
         */
        export function observe(aSubject: any, aTopic: any, aData: any): void;
        /**
         * Replaces %...% strings in an addon url (update and updateInfo) with
         * appropriate values.
         *
         * @param  aAddon
         *         The Addon representing the add-on
         * @param  aUri
         *         The string representation of the URI to escape
         * @param  aAppVersion
         *         The optional application version to use for %APP_VERSION%
         * @return The appropriately escaped URI.
         */
        export function escapeAddonURI(aAddon: any, aUri: any, aAppVersion: any): string;
        export function _updatePromptHandler(info: any): Promise<any>;
        export function systemUpdateEnabled(): boolean;
        /**
         * Performs a background update check by starting an update for all add-ons
         * that can be updated.
         * @return Promise{null} Resolves when the background update check is complete
         *                       (the resulting addon installations may still be in progress).
         */
        export function backgroundUpdateCheck(): Promise<void>;
        /**
         * Adds a add-on to the list of detected changes for this startup. If
         * addStartupChange is called multiple times for the same add-on in the same
         * startup then only the most recent change will be remembered.
         *
         * @param  aType
         *         The type of change as a string. Providers can define their own
         *         types of changes or use the existing defined STARTUP_CHANGE_*
         *         constants
         * @param  aID
         *         The ID of the add-on
         */
        export function addStartupChange(aType: any, aID: any): void;
        /**
         * Removes a startup change for an add-on.
         *
         * @param  aType
         *         The type of change
         * @param  aID
         *         The ID of the add-on
         */
        export function removeStartupChange(aType: any, aID: any): void;
        /**
         * Calls all registered AddonManagerListeners with an event. Any parameters
         * after the method parameter are passed to the listener.
         *
         * @param  aMethod
         *         The method on the listeners to call
         */
        export function callManagerListeners(aMethod: any, ...aArgs: any[]): void;
        /**
         * Calls all registered InstallListeners with an event. Any parameters after
         * the extraListeners parameter are passed to the listener.
         *
         * @param  aMethod
         *         The method on the listeners to call
         * @param  aExtraListeners
         *         An optional array of extra InstallListeners to also call
         * @return false if any of the listeners returned false, true otherwise
         */
        export function callInstallListeners(aMethod: any, aExtraListeners: any, ...aArgs: any[]): boolean;
        /**
         * Calls all registered AddonListeners with an event. Any parameters after
         * the method parameter are passed to the listener.
         *
         * @param  aMethod
         *         The method on the listeners to call
         */
        export function callAddonListeners(aMethod: any, ...aArgs: any[]): void;
        /**
         * Notifies all providers that an add-on has been enabled when that type of
         * add-on only supports a single add-on being enabled at a time. This allows
         * the providers to disable theirs if necessary.
         *
         * @param  aID
         *         The ID of the enabled add-on
         * @param  aType
         *         The type of the enabled add-on
         * @param  aPendingRestart
         *         A boolean indicating if the change will only take place the next
         *         time the application is restarted
         */
        export function notifyAddonChanged(aID: any, aType: any, aPendingRestart: any): Promise<void>;
        /**
         * Notifies all providers they need to update the appDisabled property for
         * their add-ons in response to an application change such as a blocklist
         * update.
         */
        export function updateAddonAppDisabledStates(): void;
        /**
         * Notifies all providers that the repository has updated its data for
         * installed add-ons.
         */
        export function updateAddonRepositoryData(): Promise<void>;
        /**
         * Asynchronously gets an AddonInstall for a URL.
         *
         * @param  aUrl
         *         The string represenation of the URL where the add-on is located
         * @param  {Object} [aOptions = {}]
         *         Additional options for this install
         * @param  {string} [aOptions.hash]
         *         An optional hash of the add-on
         * @param  {string} [aOptions.name]
         *         An optional placeholder name while the add-on is being downloaded
         * @param  {string|Object} [aOptions.icons]
         *         Optional placeholder icons while the add-on is being downloaded
         * @param  {string} [aOptions.version]
         *         An optional placeholder version while the add-on is being downloaded
         * @param  {XULElement} [aOptions.browser]
         *         An optional <browser> element for download permissions prompts.
         * @param  {nsIPrincipal} [aOptions.triggeringPrincipal]
         *         The principal which is attempting to install the add-on.
         * @param  {Object} [aOptions.telemetryInfo]
         *         An optional object which provides details about the installation source
         *         included in the addon manager telemetry events.
         * @throws if aUrl is not specified or if an optional argument of
         *         an improper type is passed.
         */
        export function getInstallForURL(aUrl: any, aOptions?: {
            hash?: string;
            name?: string;
            icons?: any;
            version?: string;
            browser?: XULElement;
            triggeringPrincipal?: nsIPrincipal;
            telemetryInfo?: any;
        }): Promise<any>;
        /**
         * Asynchronously gets an AddonInstall for an nsIFile.
         *
         * @param  aFile
         *         The nsIFile where the add-on is located
         * @param  aMimetype
         *         An optional mimetype hint for the add-on
         * @param  aTelemetryInfo
         *         An optional object which provides details about the installation source
         *         included in the addon manager telemetry events.
         * @param  aUseSystemLocation
         *         If true the addon is installed into the system profile location.
         * @throws if the aFile or aCallback arguments are not specified
         */
        export function getInstallForFile(aFile: any, aMimetype: any, aTelemetryInfo: any, aUseSystemLocation: any): Promise<any>;
        /**
         * Get a SitePermsAddonInstall instance.
         *
         * @param  {Element} aBrowser: The optional browser element that started the install
         * @param {nsIPrincipal} aInstallingPrincipal
         * @param {String} aSitePerm
         * @returns {Promise<SitePermsAddonInstall|null>} The promise will resolve with null if there
         *         are no provider with a getSitePermsAddonInstallForWebpage method. In practice,
         *         this should only be the case when SitePermsAddonProvider is not enabled,
         *         i.e. when dom.sitepermsaddon-provider.enabled is false.
         * @throws {Components.Exception} Will throw an error if:
         *         - the AddonManager is not initialized
         *         - `aInstallingPrincipal` is not a nsIPrincipal
         *         - `aInstallingPrincipal` scheme is not https
         *         - `aInstallingPrincipal` is a public etld
         *         - `aInstallingPrincipal` is a plain ip address
         *         - `aInstallingPrincipal` is in the blocklist
         *         - `aSitePerm` is not a gated permission
         *         - `aBrowser` is not null and not an element
         */
        export function getSitePermsAddonInstallForWebpage(aBrowser: Element, aInstallingPrincipal: nsIPrincipal, aSitePerm: string): Promise<any>;
        /**
         * Uninstall an addon from the system profile location.
         *
         * @param {string} aID
         *         The ID of the addon to remove.
         * @returns A promise that resolves when the addon is uninstalled.
         */
        export function uninstallSystemProfileAddon(aID: string): any;
        /**
         * Asynchronously gets all current AddonInstalls optionally limiting to a list
         * of types.
         *
         * @param  aTypes
         *         An optional array of types to retrieve. Each type is a string name
         * @throws If the aCallback argument is not specified
         */
        export function getInstallsByTypes(aTypes: any): Promise<any[]>;
        /**
         * Asynchronously gets all current AddonInstalls.
         */
        export function getAllInstalls(): Promise<any[]>;
        /**
         * Checks whether installation is enabled for a particular mimetype.
         *
         * @param  aMimetype
         *         The mimetype to check
         * @return true if installation is enabled for the mimetype
         */
        export function isInstallEnabled(aMimetype: any): boolean;
        /**
         * Checks whether a particular source is allowed to install add-ons of a
         * given mimetype.
         *
         * @param  aMimetype
         *         The mimetype of the add-on
         * @param  aInstallingPrincipal
         *         The nsIPrincipal that initiated the install
         * @return true if the source is allowed to install this mimetype
         */
        export function isInstallAllowed(aMimetype: any, aInstallingPrincipal: any): boolean;
        /**
         * Checks whether a particular source is allowed to install add-ons based
         * on policy.
         *
         * @param  aInstallingPrincipal
         *         The nsIPrincipal that initiated the install
         * @param  aInstall
         *         The AddonInstall to be installed
         * @param  explicit
         *         If this is set, we only return true if the source is explicitly
         *         blocked via policy.
         *
         * @return boolean
         *         By default, returns true if the source is blocked by policy
         *         or there is no policy.
         *         If explicit is set, only returns true of the source is
         *         blocked by policy, false otherwise. This is needed for
         *         handling inverse cases.
         */
        export function isInstallAllowedByPolicy(aInstallingPrincipal: any, aInstall: any, explicit: any): boolean;
        export function installNotifyObservers(aTopic: any, aBrowser: any, aUri: any, aInstall: any, aInstallFn: any, aCancelFn: any): void;
        export function startInstall(browser: any, url: any, install: any): void;
        /**
         * Starts installation of a SitePermsAddonInstall notifying the registered
         * web install listener of a blocked or started install.
         *
         * @param  aBrowser
         *         The optional browser element that started the install
         * @param  aInstallingPrincipal
         *         The nsIPrincipal that initiated the install
         * @param  aPermission
         *         The permission to install
         * @returns {Promise} A promise that will resolve when the user installs the addon.
         *         The promise will reject if the user blocked the install, or if the addon
         *         can't be installed (e.g. the principal isn't supported).
         * @throws {Components.Exception} Will throw an error if the AddonManager is not initialized
         *         or if `aInstallingPrincipal` is not a nsIPrincipal.
         */
        export function installSitePermsAddonFromWebpage(aBrowser: any, aInstallingPrincipal: any, aPermission: any): Promise<any>;
        /**
         * Starts installation of an AddonInstall notifying the registered
         * web install listener of a blocked or started install.
         *
         * @param  aMimetype
         *         The mimetype of the add-on being installed
         * @param  aBrowser
         *         The optional browser element that started the install
         * @param  aInstallingPrincipal
         *         The nsIPrincipal that initiated the install
         * @param  aInstall
         *         The AddonInstall to be installed
         * @param  [aDetails]
         *         Additional optional details
         * @param  [aDetails.hasCrossOriginAncestor]
         *         Boolean value set to true if any of cross-origin ancestors of the triggering frame
         *         (if set to true the installation will be denied).
         */
        export function installAddonFromWebpage(aMimetype: any, aBrowser: any, aInstallingPrincipal: any, aInstall: any, aDetails?: any): void;
        /**
         * Starts installation of an AddonInstall created from add-ons manager
         * front-end code (e.g., drag-and-drop of xpis or "Install Add-on from File"
         *
         * @param  browser
         *         The browser element where the installation was initiated
         * @param  uri
         *         The URI of the page where the installation was initiated
         * @param  install
         *         The AddonInstall to be installed
         */
        export function installAddonFromAOM(browser: any, uri: any, install: any): void;
        /**
         * Adds a new InstallListener if the listener is not already registered.
         *
         * @param  aListener
         *         The InstallListener to add
         */
        export function addInstallListener(aListener: any): void;
        /**
         * Removes an InstallListener if the listener is registered.
         *
         * @param  aListener
         *         The InstallListener to remove
         */
        export function removeInstallListener(aListener: any): void;
        /**
         * Adds new or overrides existing UpgradeListener.
         *
         * @param  aInstanceID
         *         The instance ID of an addon to register a listener for.
         * @param  aCallback
         *         The callback to invoke when updates are available for this addon.
         * @throws if there is no addon matching the instanceID
         */
        export function addUpgradeListener(aInstanceID: any, aCallback: any): void;
        /**
         * Removes an UpgradeListener if the listener is registered.
         *
         * @param  aInstanceID
         *         The instance ID of the addon to remove
         */
        export function removeUpgradeListener(aInstanceID: any): void;
        export function addExternalExtensionLoader(loader: any): void;
        /**
         * Installs a temporary add-on from a local file or directory.
         *
         * @param  aFile
         *         An nsIFile for the file or directory of the add-on to be
         *         temporarily installed.
         * @returns a Promise that rejects if the add-on is not a valid restartless
         *          add-on or if the same ID is already temporarily installed.
         */
        export function installTemporaryAddon(aFile: any): any;
        /**
         * Installs an add-on from a built-in location
         *  (ie a resource: url referencing assets shipped with the application)
         *
         * @param  aBase
         *         A string containing the base URL.  Must be a resource: URL.
         * @returns a Promise that resolves when the addon is installed.
         */
        export function installBuiltinAddon(aBase: any): any;
        /**
         * Like `installBuiltinAddon`, but only installs the addon at `aBase`
         * if an existing built-in addon with the ID `aID` and version doesn't
         * already exist.
         *
         * @param {string} aID
         *        The ID of the add-on being registered.
         * @param {string} aVersion
         *        The version of the add-on being registered.
         * @param {string} aBase
         *        A string containing the base URL.  Must be a resource: URL.
         * @returns a Promise that resolves when the addon is installed.
         */
        export function maybeInstallBuiltinAddon(aID: string, aVersion: string, aBase: string): any;
        export function syncGetAddonIDByInstanceID(aInstanceID: any): any;
        /**
         * Gets an icon from the icon set provided by the add-on
         * that is closest to the specified size.
         *
         * The optional window parameter will be used to determine
         * the screen resolution and select a more appropriate icon.
         * Calling this method with 48px on retina screens will try to
         * match an icon of size 96px.
         *
         * @param  aAddon
         *         An addon object, meaning:
         *         An object with either an icons property that is a key-value list
         *         of icon size and icon URL, or an object having an iconURL property.
         * @param  aSize
         *         Ideal icon size in pixels
         * @param  aWindow
         *         Optional window object for determining the correct scale.
         * @return {String} The absolute URL of the icon or null if the addon doesn't have icons
         */
        export function getPreferredIconURL(aAddon: any, aSize: any, aWindow?: any): string;
        export namespace getAddonByID { }
        /**
         * Asynchronously get an add-on with a specific Sync GUID.
         *
         * @param  aGUID
         *         String GUID of add-on to retrieve
         * @throws if the aGUID argument is not specified
         */
        export function getAddonBySyncGUID(aGUID: any): Promise<any>;
        /**
         * Asynchronously gets an array of add-ons.
         *
         * @param  aIDs
         *         The array of IDs to retrieve
         * @return {Promise}
         * @resolves The array of found add-ons.
         * @rejects  Never
         * @throws if the aIDs argument is not specified
         */
        export function getAddonsByIDs(aIDs: any): Promise<any>;
        /**
         * Asynchronously gets add-ons of specific types.
         *
         * @param  aTypes
         *         An optional array of types to retrieve. Each type is a string name
         */
        export function getAddonsByTypes(aTypes: any): Promise<any[]>;
        /**
         * Gets active add-ons of specific types.
         *
         * This is similar to getAddonsByTypes() but it may return a limited
         * amount of information about only active addons.  Consequently, it
         * can be implemented by providers using only immediately available
         * data as opposed to getAddonsByTypes which may require I/O).
         *
         * @param  aTypes
         *         An optional array of types to retrieve. Each type is a string name
         *
         * @resolve {addons: Array, fullData: bool}
         *          fullData is true if addons contains all the data we have on those
         *          addons. It is false if addons only contains partial data.
         */
        export function getActiveAddons(aTypes: any): Promise<{
            addons: any[];
            fullData: boolean;
        }>;
        /**
         * Asynchronously gets all installed add-ons.
         */
        export function getAllAddons(): Promise<any[]>;
        /**
         * Adds a new AddonManagerListener if the listener is not already registered.
         *
         * @param {AddonManagerListener} aListener
         *         The listener to add
         */
        export function addManagerListener(aListener: AddonManagerListener): void;
        /**
         * Removes an AddonManagerListener if the listener is registered.
         *
         * @param {AddonManagerListener} aListener
         *         The listener to remove
         */
        export function removeManagerListener(aListener: AddonManagerListener): void;
        /**
         * Adds a new AddonListener if the listener is not already registered.
         *
         * @param {AddonManagerListener} aListener
         *        The AddonListener to add.
         */
        export function addAddonListener(aListener: AddonManagerListener): void;
        /**
         * Removes an AddonListener if the listener is registered.
         *
         * @param {object}  aListener
         *         The AddonListener to remove
         */
        export function removeAddonListener(aListener: any): void;
        /**
         * @param {string} addonType
         * @returns {boolean}
         *          Whether there is a provider that provides the given addon type.
         */
        export function hasAddonType(addonType: string): boolean;
        export let autoUpdateDefault: boolean;
        export let checkCompatibility: boolean;
        export let strictCompatibility: boolean;
        export const checkUpdateSecurityDefault: boolean;
        export let checkUpdateSecurity: boolean;
        export let updateEnabled: boolean;
        /**
         * Verify whether we need to show the 3rd party install prompt.
         *
         * Bypass the third party install prompt if this is an install:
         *   - is an install from a recognized source
         *   - is a an addon that can bypass the panel, such as a recommended addon
         *
         * @param {browser}      browser browser user is installing from
         * @param {nsIURI}       url     URI for the principal of the installing source
         * @param {AddonInstallWrapper} install
         * @param {Object}       info    information such as addon wrapper
         * @param {AddonWrapper} info.addon
         * @param {string}       source  simplified string describing source of install and is
         *                               generated based on the installing principal and checking
         *                               against site permissions and enterprise policy.
         *                               It may be one of "AMO", "local" or "other".
         * @returns {Promise}            Rejected when the installation should not proceed.
         */
        export function _verifyThirdPartyInstall(browser: any, url: nsIURI, install: AddonInstallWrapper, info: {
            addon: AddonWrapper;
        }, source: string): Promise<any>;
        export function setupPromptHandler(browser: any, url: any, install: any, requireConfirm: any, source: any): void;
        export namespace webAPI {
            let installs: Map<any, any>;
            let nextInstall: number;
            let sendEvent: any;
            function setEventHandler(fn: any): void;
            function getAddonByID(target: any, id: any): Promise<{
                isEnabled: boolean;
                canUninstall: boolean;
            }>;
            function copyProps(install: any, obj: any): void;
            function forgetInstall(id: any): void;
            function createInstall(target: any, options: any): Promise<{
                id: number;
            }>;
            function addonUninstall(target: any, id: any): Promise<boolean>;
            function addonSetEnabled(target: any, id: any, value: any): Promise<void>;
            function addonInstallDoInstall(target: any, id: any): Promise<void>;
            function addonInstallCancel(target: any, id: any): Promise<any>;
            function clearInstalls(ids: any): void;
            function clearInstallsFrom(mm: any): void;
            function addonReportAbuse(target: any, id: any): Promise<any>;
        }
    }
    export const isReady: boolean;
    export const readyPromise: Promise<any>;
    /** @constructor */
    export function init(): void;
    export function stateToString(state: any): any;
    export function errorToString(err: any): any;
    export function getInstallSourceFromHost(host: any): string;
    export function getInstallForURL(aUrl: any, aOptions: any): Promise<any>;
    export function getInstallForFile(aFile: any, aMimetype: any, aTelemetryInfo: any, aUseSystemLocation?: boolean): Promise<any>;
    export function uninstallSystemProfileAddon(aID: any): any;
    export function stageLangpacksForAppUpdate(appVersion: any, platformVersion: any): any;
    /**
     * Gets an array of add-on IDs that changed during the most recent startup.
     *
     * @param  aType
     *         The type of startup change to get
     * @return An array of add-on IDs
     */
    export function getStartupChanges(aType: any): any;
    export function getAddonByID(aID: any): any;
    export function getAddonBySyncGUID(aGUID: any): Promise<any>;
    export function getAddonsByIDs(aIDs: any): Promise<any>;
    export function getAddonsByTypes(aTypes: any): Promise<any[]>;
    export function getActiveAddons(aTypes: any): Promise<{
        addons: any[];
        fullData: boolean;
    }>;
    export function getAllAddons(): Promise<any[]>;
    export function getInstallsByTypes(aTypes: any): Promise<any[]>;
    export function getAllInstalls(): Promise<any[]>;
    export function isInstallEnabled(aType: any): boolean;
    export function isInstallAllowed(aType: any, aInstallingPrincipal: any): boolean;
    export function installSitePermsAddonFromWebpage(aBrowser: any, aInstallingPrincipal: any, aPermission: any): Promise<any>;
    export function installAddonFromWebpage(aType: any, aBrowser: any, aInstallingPrincipal: any, aInstall: any, details: any): void;
    export function installAddonFromAOM(aBrowser: any, aUri: any, aInstall: any): void;
    export function installTemporaryAddon(aDirectory: any): any;
    export function installBuiltinAddon(aBase: any): any;
    export function maybeInstallBuiltinAddon(aID: any, aVersion: any, aBase: any): any;
    export function addManagerListener(aListener: any): void;
    export function removeManagerListener(aListener: any): void;
    export function addInstallListener(aListener: any): void;
    export function removeInstallListener(aListener: any): void;
    export function getUpgradeListener(aId: any): any;
    export function addUpgradeListener(aInstanceID: any, aCallback: any): void;
    export function removeUpgradeListener(aInstanceID: any): void;
    export function addExternalExtensionLoader(loader: any): void;
    export function addAddonListener(aListener: any): void;
    export function removeAddonListener(aListener: any): void;
    export function hasAddonType(addonType: any): boolean;
    export function hasProvider(name: any): boolean;
    /**
     * Determines whether an Addon should auto-update or not.
     *
     * @param  aAddon
     *         The Addon representing the add-on
     * @return true if the addon should auto-update, false otherwise.
     */
    export function shouldAutoUpdate(aAddon: any): boolean;
    let checkCompatibility_1: boolean;
    export { checkCompatibility_1 as checkCompatibility };
    let strictCompatibility_1: boolean;
    export { strictCompatibility_1 as strictCompatibility };
    const checkUpdateSecurityDefault_1: boolean;
    export { checkUpdateSecurityDefault_1 as checkUpdateSecurityDefault };
    let checkUpdateSecurity_1: boolean;
    export { checkUpdateSecurity_1 as checkUpdateSecurity };
    let updateEnabled_1: boolean;
    export { updateEnabled_1 as updateEnabled };
    let autoUpdateDefault_1: boolean;
    export { autoUpdateDefault_1 as autoUpdateDefault };
    export function escapeAddonURI(aAddon: any, aUri: any, aAppVersion: any): string;
    export function getPreferredIconURL(aAddon: any, aSize: any, aWindow?: any): string;
    export namespace webAPI_1 { }
    export { webAPI_1 as webAPI };
    export const beforeShutdown: any;
}
/**
 * This represents an author of an add-on (e.g. creator or developer)
 *
 * @param  aName
 *         The name of the author
 * @param  aURL
 *         The URL of the author's profile page
 */
declare function AddonAuthor(aName: any, aURL: any): void;
declare class AddonAuthor {
    /**
     * This represents an author of an add-on (e.g. creator or developer)
     *
     * @param  aName
     *         The name of the author
     * @param  aURL
     *         The URL of the author's profile page
     */
    constructor(aName: any, aURL: any);
    name: null;
    url: null;
    toString(): string;
}
/**
 * This represents an screenshot for an add-on
 *
 * @param  aURL
 *         The URL to the full version of the screenshot
 * @param  aWidth
 *         The width in pixels of the screenshot
 * @param  aHeight
 *         The height in pixels of the screenshot
 * @param  aThumbnailURL
 *         The URL to the thumbnail version of the screenshot
 * @param  aThumbnailWidth
 *         The width in pixels of the thumbnail version of the screenshot
 * @param  aThumbnailHeight
 *         The height in pixels of the thumbnail version of the screenshot
 * @param  aCaption
 *         The caption of the screenshot
 */
declare function AddonScreenshot(aURL: any, aWidth: any, aHeight: any, aThumbnailURL: any, aThumbnailWidth: any, aThumbnailHeight: any, aCaption: any): void;
declare class AddonScreenshot {
    /**
     * This represents an screenshot for an add-on
     *
     * @param  aURL
     *         The URL to the full version of the screenshot
     * @param  aWidth
     *         The width in pixels of the screenshot
     * @param  aHeight
     *         The height in pixels of the screenshot
     * @param  aThumbnailURL
     *         The URL to the thumbnail version of the screenshot
     * @param  aThumbnailWidth
     *         The width in pixels of the thumbnail version of the screenshot
     * @param  aThumbnailHeight
     *         The height in pixels of the thumbnail version of the screenshot
     * @param  aCaption
     *         The caption of the screenshot
     */
    constructor(aURL: any, aWidth: any, aHeight: any, aThumbnailURL: any, aThumbnailWidth: any, aThumbnailHeight: any, aCaption: any);
    url: null;
    width: null;
    height: null;
    thumbnailURL: null;
    thumbnailWidth: null;
    thumbnailHeight: null;
    caption: null;
    toString(): string;
}
export {};
