/**
 * Creates an IdP helper.
 *
 * @param win (object) the window we are working for
 * @param timeout (int) the timeout in milliseconds
 */
export function PeerConnectionIdp(win: any, timeout: any): void;
export class PeerConnectionIdp {
    /**
     * Creates an IdP helper.
     *
     * @param win (object) the window we are working for
     * @param timeout (int) the timeout in milliseconds
     */
    constructor(win: any, timeout: any);
    _win: any;
    _timeout: any;
    provider: any;
    get enabled(): boolean;
    _resetAssertion(): void;
    assertion: string;
    idpLoginUrl: any;
    setIdentityProvider(provider: any, protocol: any, usernameHint: any, peerIdentity: any): void;
    protocol: any;
    username: any;
    peeridentity: any;
    _idp: any;
    start(): any;
    close(): void;
    _getFingerprintsFromSdp(sdp: any): any[];
    _isValidAssertion(assertion: any): boolean;
    _getSessionLevelEnd(sdp: any): any;
    _getIdentityFromSdp(sdp: any): any;
    /**
     * Verifies the a=identity line the given SDP contains, if any.
     * If the verification succeeds callback is called with the message from the
     * IdP proxy as parameter, else (verification failed OR no a=identity line in
     * SDP at all) null is passed to callback.
     *
     * Note that this only verifies that the SDP is coherent.  We still rely on
     * the fact that the RTCPeerConnection won't connect to a peer if the
     * fingerprint of the certificate they offer doesn't appear in the SDP.
     */
    verifyIdentityFromSDP(sdp: any, origin: any): any;
    /**
     * Checks that the name in the identity provided by the IdP is OK.
     *
     * @param name (string) the name to validate
     * @throws if the name isn't valid
     */
    _validateName(name: any): void;
    /**
     * Check the validation response.  We are very defensive here when handling
     * the message from the IdP proxy.  That way, broken IdPs aren't likely to
     * cause catastrophic damage.
     */
    _checkValidation(validation: any, sdpFingerprints: any): any;
    /**
     * Asks the IdP proxy to verify an identity assertion.
     */
    _verifyIdentity(assertion: any, fingerprints: any, origin: any): any;
    /**
     * Enriches the given SDP with an `a=identity` line.  getIdentityAssertion()
     * must have already run successfully, otherwise this does nothing to the sdp.
     */
    addIdentityAttribute(sdp: any): any;
    /**
     * Asks the IdP proxy for an identity assertion.  Don't call this unless you
     * have checked .enabled, or you really like exceptions.  Also, don't call
     * this when another call is still running, because it's not certain which
     * call will finish first and the final state will be similarly uncertain.
     */
    getIdentityAssertion(fingerprint: any, origin: any): any;
    /**
     * Promises generated by the sandbox need to be very carefully treated so that
     * they can chain into promises in the `this._win` compartment.  Results need
     * to be cloned across; errors need to be converted.
     */
    _wrapCrossCompartmentPromise(sandboxPromise: any): any;
    /**
     * Wraps a promise, adding a timeout guard on it so that it can't take longer
     * than the specified time.  Returns a promise that rejects if the timeout
     * elapses before `p` resolves.
     */
    _applyTimeout(p: any): any;
}
